<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<p>Monolitic and why?:</p>
<ul>
<li>faster develop</li>
<li><p>its only my machine</p></li>
<li>If the app is big. My machine is suffering</li>
<li><p>scale vertical (best performance &lt;-&gt; best machine)</p></li>
</ul>
<p>12 - factors (heroku):</p>
<p>https://12factor.net/ I. Código base (Codebase) Un código base sobre el que hacer el control de versiones y multiples despliegues II. Dependencias Declarar y aislar explícitamente las dependencias III. Configuraciones Guardar la configuración en el entorno IV. Backing services Tratar a los “backing services” como recursos conectables V. Construir, desplegar, ejecutar Separar completamente la etapa de construcción de la etapa de ejecución VI. Procesos Ejecutar la aplicación como uno o más procesos sin estado VII. Asignación de puertos Publicar servicios mediante asignación de puertos VIII. Concurrencia Escalar mediante el modelo de procesos IX. Desechabilidad Hacer el sistema más robusto intentando conseguir inicios rápidos y finalizaciones seguras X. Paridad en desarrollo y producción Mantener desarrollo, preproducción y producción tan parecidos como sea posible XI. Historiales Tratar los historiales como una transmisión de eventos XII. Administración de procesos Ejecutar las tareas de gestión/administración como procesos que solo se ejecutan una vez</p>
<p>Lo que ya tenía:</p>
<ul>
<li>I. Código base (Codebase)</li>
<li><ol start="2" style="list-style-type: upper-roman">
<li>Dependencias</li>
</ol></li>
<li>V. Construir, desplegar, ejecutar</li>
<li><ol start="12" style="list-style-type: upper-roman">
<li>Administración de procesos</li>
</ol></li>
</ul>
<p>Dividir los servicios más pesados (las cosas clasicas, base de datos, autentaticacion) No son nuestra responsabilidad (IV. Backing services):</p>
<ul>
<li>Bases de Datos</li>
<li>Sistemas de autenticación</li>
<li>Control de versiones</li>
<li>almacenamiento (Minio.io)</li>
</ul>
<p>Dividir las tareas en micro servicios (Como levantar todo a la vez):</p>
<ul>
<li>Desechar es facil !!!!!!</li>
<li>Orquestar como se levanta la aplicación</li>
<li>La ventaja de que los servicios pueden escalar independientemente</li>
<li>(III. Configuraciones, VI. Procesos, IX. Desechabilidad)</li>
</ul>
<p>Production - Stage:</p>
<ul>
<li>Tener dos ambientes separados para poder probar nuestro código y como funciona (stage no es nuestra pc) (X. Paridad en desarrollo y producción)</li>
</ul>
<p>Continuos Delivery and Deployment (test correctitud, mejor calidad de software):</p>
<ul>
<li>Unitest are important</li>
<li>Code Coverage</li>
<li>El deploy de la aplicación no debe requerir intervención humana</li>
<li>Jenkis - Gitlab</li>
</ul>
<p>Lo más cercano que tenemos es un sistema altamente virtualizado:</p>
<ul>
<li>Necesitamos mejores gestores de nube e incluir orquestadores</li>
<li>Utilizar soluciones opensource como rancher OS para manejar de forma más sencilla Kubernetes</li>
<li>Almacenamiento, BD, Servicios en Kubernetes (load balace, health check, etc, load balance, etc muchos problemas resueltos, logs)</li>
<li>Hot refresh</li>
<li>Escribir kubernetes is hard</li>
<li>Plataform as a service (flynn.io)</li>
</ul>
<p>Extra Notes:</p>
<ul>
<li>Buscar estructuras de software más horizontales (si alguien tiene una idea y la programó, no debe tardar más de un día en ponerla en producción)</li>
<li>Ofrecer como servicio las mayores necesidad de los programadores (bases de datos, servicios de integración, repositorios) esto acelera la producción del software</li>
<li>Los mejores patrones de software para estas arquitecturas</li>
</ul>
</body>
</html>
